package pt.isel

import java.lang.reflect.ParameterizedType
import org.cojen.maker.ClassMaker
import kotlin.reflect.KClass

/**
 * A YamlParser that uses Cojen Maker to generate a parser.
 */
open class YamlParserCojen<T : Any> protected constructor(
    private val type: KClass<T>,
    private val nrOfInitArgs: Int)
: AbstractYamlParser<T>(type) {

    companion object {
        private val yamlParsers: MutableMap<String, YamlParserCojen<*>> = mutableMapOf()

        private fun parserName(type: KClass<*>, nrOfInitArgs: Int): String {
            return "YamlParser${type.simpleName}$nrOfInitArgs"
        }
        /**
         * Creates a YamlParser for the given type using Cojen Maker if it does not already exist.
         * Keep it in an internal cache.
         */
        fun <T : Any> yamlParser(type: KClass<T>, nrOfInitArgs: Int = type.constructors.first().parameters.size): AbstractYamlParser<T> {
            return yamlParsers.getOrPut(parserName(type, nrOfInitArgs)) {
                YamlParserCojen(type, nrOfInitArgs)
                    .buildYamlParser()
                    .finish()
                    .getConstructor(KClass::class.java, Integer::class.java)
                    .newInstance(type, nrOfInitArgs) as YamlParserCojen<*>
            } as YamlParserCojen<T>
        }
    }
    /**
     * Used to get a parser for other Type using the same parsing approach.
     */
    override fun <T : Any> yamlParser(type: KClass<T>) = YamlParserCojen.yamlParser(type)

    fun <T : Any> yamlParser(type: Class<T>): AbstractYamlParser<T>{
        return yamlParser(type.kotlin)
    }

    /**
     * Do not change this method in YamlParserCojen.
     */
    override fun newInstance(args: Map<String, Any>): T {
        throw UnsupportedOperationException("This method is overridden in a subclass dynamically generated by buildYamlParser() function!")
    }

    private fun buildYamlParser() : ClassMaker {
        return ClassMaker
            .begin("YamlParser${type.simpleName}${nrOfInitArgs}")
            .public_()
            .extend(YamlParserCojen::class.java)
            .apply {
                addConstructor(KClass::class.java, Integer::class.java)
                    .public_()
                    .also { ctor ->
                        ctor.invokeSuperConstructor(ctor.param(0), ctor.param(1))
                    }
                if(type.javaPrimitiveType == null && type != String::class)
                    addParseMethod(type)
            }

    }

    private fun ClassMaker.addParseMethod(destType: KClass<T>) {
        val javaType = destType.java
        // get the right constructor
        val destInit = javaType
            .constructors.first {
                it.parameters.size == nrOfInitArgs
            }

        // add the parse method
        addMethod(Any::class.java, "newInstance", Map::class.java)
            .public_()
            .apply {
                val argMap = param(0)
                val argValues = destInit.parameters.map { param ->
                    val paramName = param.name
                    when (val v = param.type) {
                        String::class.java -> argMap.invoke("get", paramName).cast(String::class.java)
                        Int::class.java ->
                            `var`(v).invoke("parseInt", argMap.invoke("get", paramName).cast(String::class.java))

                        Short::class.java ->
                            `var`(v).invoke("parseShort", argMap.invoke("get", paramName).cast(String::class.java))

                        Long::class.java ->
                            `var`(v).invoke("parseLong", argMap.invoke("get", paramName).cast(String::class.java))

                        Boolean::class.java ->
                            `var`(v).invoke("parseBoolean", argMap.invoke("get", paramName).cast(String::class.java))

                        Double::class.java ->
                            `var`(v).invoke("parseDouble", argMap.invoke("get", paramName).cast(String::class.java))

                        Float::class.java ->
                            `var`(v).invoke("parseFloat", argMap.invoke("get", paramName).cast(String::class.java))

                        Byte::class.java ->
                            `var`(v).invoke("parseByte", argMap.invoke("get", paramName).cast(String::class.java))

                        List::class.java -> {
                            val argSeq = argMap.invoke("get", paramName).cast(v)
                            val elemType =
                                (destInit.parameters.first{ it.name == paramName }.parameterizedType as ParameterizedType)
                                    .actualTypeArguments[0] as Class<*>
                            val parser = super_().invoke("yamlParser", elemType)
                            val argSeqSize = argSeq.invoke("size").cast(Int::class.java) // argSeq.size()
                            val i = `var`(Int::class.java).set(0) // i = 0
                            val retList = new_(ArrayList::class.java, argSeqSize)
                            val endLabel = label()
                            val startLabel = label().here()
                            i.ifGe(argSeqSize, endLabel) // i >= argSeq.size()
                            val elemMap =
                                argSeq.invoke("get", i.cast(Int::class.java)).cast(Map::class.java)
                            val parsedElem = parser.invoke("newInstance", elemMap).cast(elemType)
                            retList.invoke("add", parsedElem)
                            i.inc(1) // i++
                            goto_(startLabel)
                            endLabel.here()
                            return@map retList
                        }

                        else -> super_()
                            .invoke("yamlParser", v)
                            .invoke("newInstance", argMap.invoke("get", paramName).cast(Map::class.java))
                            .cast(v)
                    }
                }
                this.return_(this.new_(javaType, *argValues.toTypedArray()))
            }
    }
}


package pt.isel

import org.cojen.maker.ClassMaker
import org.cojen.maker.MethodMaker
import org.cojen.maker.Variable
import java.lang.reflect.Parameter
import kotlin.reflect.KClass
/**
 * A YamlParser that uses Cojen Maker to generate a parser.
 */
open class YamlParserCojen<T : Any>(
    private val type: KClass<T>,
    private val nrOfInitArgs: Int)
: AbstractYamlParser<T>(type) {

    companion object {
        private val yamlParsers: MutableMap<String, YamlParserCojen<*>> = mutableMapOf()

        private fun parserName(type: KClass<*>, nrOfInitArgs: Int): String {
            return "YamlParser${type.simpleName}$nrOfInitArgs"
        }
        /**
         * Creates a YamlParser for the given type using Cojen Maker if it does not already exist.
         * Keep it in an internal cache.
         */
        fun <T : Any> yamlParser(type: KClass<T>, nrOfInitArgs: Int = type.constructors.first().parameters.size): AbstractYamlParser<T> {
            return yamlParsers.getOrPut(parserName(type, nrOfInitArgs)) {
                YamlParserCojen(type, nrOfInitArgs)
                    .buildYamlParser()
                    .finish()
                    .getConstructor(KClass::class.java, Integer::class.java)
                    .newInstance(type, nrOfInitArgs) as YamlParserCojen<*>
            } as YamlParserCojen<T>
        }
    }
    /**
     * Used to get a parser for other Type using the same parsing approach.
     */
    override fun <T : Any> yamlParser(type: KClass<T>) = YamlParserCojen.yamlParser(type)

    /**
     * Do not change this method in YamlParserCojen.
     */
    override fun newInstance(args: Map<String, Any>): T {
        throw UnsupportedOperationException("This method is overridden in a subclass dynamically generated by buildYamlParser() function!")
    }

    /**
     * Generate Student dinamically Student {
     *
     * ################ Kotlin version #################
     * class Student @JvmOverloads constructor (
     *     val name: String,
     *     val nr: Int,
     *     val from: String,
     *     val address: Address? = null,
     *     val grades: List<Grade> = emptyList()
     * )
     *
     * ################ Java version #################
     *
     * public class Student {
     *     private final String name;
     *     private final int nr;
     *     private final String from;
     *     private final Address address;
     *     private final List<Grade> grades;
     *
     *     public Student(String name, int nr, String from, Address address, List<Grade> grades) {
     *         this.name = name;
     *         this.nr = nr;
     *         this.from = from;
     *         this.address = address;
     *         this.grades = grades;
     *     }
     *
     *     public Student(String name, int nr, String from, Address address) {
     *         this(name, nr, from, address, List.of());
     *     }
     *
     *     public Student(String name, int nr, String from) {
     *         this(name, nr, from, null, List.of());
     *     }
     *
     *     public String getName() {
     *         return name;
     *     }
     *
     *     public int getNr() {
     *         return nr;
     *     }
     *
     *     public String getFrom() {
     *         return from;
     *     }
     *
     *     public Address getAddress() {
     *         return address;
     *     }
     *
     *     public List<Grade> getGrades() {
     *         return grades;
     *     }
     * }
     */

    /*
     class YamlParserStudent3 : Parser<Student> {
        override fun newInstance(args: Map<String, Any>): Student {

            val name = args["name"] as String
            val nr = args["nr"] as Int
            val from = args["from"] as String

            return Student(name, nr, from)
        }
    }

     class YamlParserStudent4(type: KClass<*>, nrArgs: Int): Parser<Student> {
        override fun newInstance(args: Map<String, Any>): Student {

            val name = args["name"] as String
            val nr = args["nr"] as Int
            val from = args["from"] as String
            return if (args.containsKey("address")) {
                val address = args["address"] as Address
                Student(name, nr, from, address = address)
            } else {
                val grades = args["grades"] as List<Grade>
                Student(name, nr, from, grades = grades)
            }
        }
    }
     */
    private fun buildYamlParser() : ClassMaker {
        return ClassMaker
            .begin("YamlParser${type.simpleName}${nrOfInitArgs}")
            .public_()
            .implement(Parser::class.java)
            .apply {
                addConstructor().public_()
                addParseMethod(type)
                //this.addConstructor(this.addParseMethod())
            }

    }

    private fun ClassMaker.addParseMethod(destType: KClass<T>) {
        // get the right constructor TODO: make it work for cases where there are multiple constructors
        val destInit = type
            .java
            .constructors.first {
                it.parameters.size == nrOfInitArgs
            }

        // get the type of each parameter
        val args = destInit.parameters.associate { it.name to it.type }

        addMethod(Any::class.java, "newInstance", Map::class.java)
            .public_()
            .apply {
                val argMap= param(0)
                //val argMap = param(0).cast(Map::class.java)
                val argValues = args.map {
                    (k, v) -> argMap.invoke("get", k).cast(v::class.java)
                }
                return_(new_(destType.java, *arrayOf("Maria", 54, "Porto")))
            }

    }
}


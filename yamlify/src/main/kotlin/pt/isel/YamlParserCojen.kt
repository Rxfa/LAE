package pt.isel

import org.cojen.maker.ClassMaker
import kotlin.reflect.KClass
import kotlin.reflect.jvm.jvmErasure
import kotlin.reflect.jvm.kotlinFunction

/**
 * A YamlParser that uses Cojen Maker to generate a parser.
 */
open class YamlParserCojen<T : Any> (
    private val type: KClass<T>,
    private val nrOfInitArgs: Int)
: AbstractYamlParser<T>(type) {

    companion object {
        private val yamlParsers: MutableMap<String, YamlParserCojen<*>> = mutableMapOf()

        private fun parserName(type: KClass<*>, nrOfInitArgs: Int): String {
            return "YamlParser${type.simpleName}$nrOfInitArgs"
        }
        /**
         * Creates a YamlParser for the given type using Cojen Maker if it does not already exist.
         * Keep it in an internal cache.
         */
        fun <T : Any> yamlParser(type: KClass<T>, nrOfInitArgs: Int = type.constructors.first().parameters.size): AbstractYamlParser<T> {
            return yamlParsers.getOrPut(parserName(type, nrOfInitArgs)) {
                YamlParserCojen(type, nrOfInitArgs)
                    .buildYamlParser()
                    .finish()
                    .getConstructor(KClass::class.java, Integer::class.java)
                    .newInstance(type, nrOfInitArgs) as YamlParserCojen<*>
            } as YamlParserCojen<T>
        }
    }
    /**
     * Used to get a parser for other Type using the same parsing approach.
     */
    override fun <T : Any> yamlParser(type: KClass<T>) = YamlParserCojen.yamlParser(type)

    fun <T : Any> yamlParser(type: Class<T>): AbstractYamlParser<T>{
        return yamlParser(type.kotlin)
    }

    /**
     * Do not change this method in YamlParserCojen.
     */
    override fun newInstance(args: Map<String, Any>): T {
        throw UnsupportedOperationException("This method is overridden in a subclass dynamically generated by buildYamlParser() function!")
    }

    private fun buildYamlParser() : ClassMaker {
        return ClassMaker
            .begin("YamlParser${type.simpleName}${nrOfInitArgs}")
            .public_()
            .extend(YamlParserCojen::class.java)
            .apply {
                addConstructor(KClass::class.java, Integer::class.java)
                    .public_()
                    .also { ctor ->
                        ctor.invokeSuperConstructor(ctor.param(0), ctor.param(1))
                    }
                addParseMethod(type)
            }

    }

    private fun ClassMaker.addParseMethod(destType: KClass<T>) {
        // get the right constructor
        val destInit = type
            .java
            .constructors.find {
                it.parameters.size == nrOfInitArgs
            }

        //val kctor = type.constructors.first().parameters.filter { it.name in destInit?.parameters.map { it.name } }

        // get the type of each parameter
        val args = destInit?.kotlinFunction?.parameters?.associate { it.name to it.type }

        // add the parse method
        addMethod(Any::class.java, "newInstance", Map::class.java)
            .public_()
            .apply {
                val argMap = param(0)

                if(destInit == null){
                    // It's either a primitive or a String
                    val arg = param(0)
                        .invoke("keySet").cast(Set::class.java)
                        .invoke("iterator").invoke("next").cast(String::class.java)
                    val value = `var`(destType.java).invoke("valueOf", arg)
                    return_(value)
                } else {
                    // It's a reference type
                    val argValues = args?.map { (k, v) ->
                        val cls = v.jvmErasure.java
                        when {
                            cls == String::class.java -> argMap.invoke("get", k).cast(String::class.java)
                            cls.isPrimitive ->
                                `var`(cls).invoke("valueOf", argMap.invoke("get", k).cast(String::class.java))
                            cls == List::class.java -> TODO("Not implemented yet")
                            cls == Sequence::class.java -> {
                                val argSeq = argMap.invoke("get", k).cast(v)
                                val elemType = v.arguments[0].type?.jvmErasure
                                val retList = new_(v) // TODO: Find out how to create a sequence
                                val parser = super_().invoke("yamlParser", v)

                                val startLabel = label()
                                val endLabel = label()

                            }
                            else ->
                                super_()
                                    .invoke("yamlParser", cls)
                                    .invoke("newInstance", argMap.invoke("get", k).cast(Map::class.java))
                                    .cast(cls)
                        }
                    }

                    val cls = this.new_(destType.java, *argValues!!.toTypedArray())
                    this.return_(cls)

                }
            }
    }
}

